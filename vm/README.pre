
# VM documentation

## Registers

### Stack pointer `sp`

Stack pointer starts at end of memory and points at the last value
pushed on the stack.

Here's a reference implementation of the stack:

	int64 size = 1024;
	byte mem[size];

	int64* start = (int64*) &mem;
	int64* end = (int64*) (&mem + size);
	int64* sp = end;

Push a value to stack:

	if (sp == start)
		error("stack overflow");
	*--sp = value;

Pop a value from stack:

	if (sp == end)
		error("stack underflow");
	value = *sp++;

### Program counter `pc`

Program counter starts at the start of memory and points at the next
instruction to be executed.  Instructions are 32-bit words.

	int64 size = 1024;
	byte mem[size];

	int32* start = (int32*) &mem;
	int32* end = (int32*) (&mem + size);
	int32* pc = start;

Here's a reference implementation of the instruction decoder:

	while (true) {
		// Decode instruction into [instr, arg1, arg2]

		if (pc < start || pc >= end)
			error("non-existent address");

		int32 instr = *pc++;

		int32 arg1, arg2;

		if (twoword(instr)) {
			if (pc < start || pc >= end)
				error("non-existent address");
			arg1 = *pc++;
		}

		if (threeword(instr)) {
			if (pc < start || pc >= end)
				error("non-existent address");
			arg2 = *pc++;
		}

		// Execute

		switch (instr) {
			// ...
		}
	}

Thus, when an instruction refers to `pc`, it will point to the next instruction
following the instruction itself.  For example,

	add pc, 4	// equivalent go 'goto foo;'
	nop			// will not be executed
foo:
	...

This code is equivalent to the one above:

	set pc, foo
	nop			// will not be executed
foo:
	...

This code results in an infinite loop, since the instruction fits into 32 bits:

	sub pc, 4

## Function call 

Before calling the function, the stack looks like:

	position	contents

				local variable 0
				...
				local variable n (previous sp)
				argument n
				...
				argument 1
				return address
	sp			previous sp

During execution of the function, the stack looks like:

	position	contents


				local variable 0
				...
				local variable n (previous sp)
				argument n
				...
				argument 1
				return address
				previous sp 
				local variable 0
				...
	sp			local variable n

After returning from the function, the stack looks like:

	position	contents

				local variable 0
				...
	sp			local variable n (previous sp)

Assembly sequence for a function call:

	// evaluate local variables arg1, arg2, arg3, and prev_sp = sp
	// a register could be used for prev_sp as well
	push arg3
	push arg2
	push arg1
	push ret
	push prev_sp
	jmp f
ret:
	...

Assembly sequence for f:

f:
	add sp, n	// allocate space for n variables
	... 		// function body

	sub sp, n	// free the allocated space
	ret

The `ret` instruction pops `sp` and `pc` from stack.

Alternatively, f could be implemented as:

f:
	push xx		// push xx
	push yy		// push yy
	push zz		// push zz
	...			// function body
	sub sp, n	// free the allocated space
	ret

The guideline is that the function body should never modify `sp` in the
function body, so that `sp`-relative locations always refer to the same local
variable.

(`ret` could also take an argument that first frees n bytes from the stack.)

## Instructions

In addition, instructions may contain up to two /long arguments/.  They take 32
bits each 

instruction contains a prefix, 

### with 0 arguments

* HALT - stop execution
* NOP  - do nothing

### with 1 argument

* PUSx - push argument denoted by x to stack
* POPx - pop value from stack and place it into `x`

### with 2 arguments

* MVxy
* 

* LOAx, 

32 opcodes should be enough.

Opcode format:

	bits 0..4   (values 0-31)    opcode 
	bits 5..7   (values 0-15)    width
	bits 8..15  (values 0..255)  target (optional)
	bits 16..23 (values 0..255)  argument 1
	bits 24..31 (values 0..255)  argument 2

	uint32 instr = get_instr();
	uint8 int opcode = instr & 0x1f;
	uint8 width = instr >> 5 & 0x07;
	uint8 target = instr >> 8 & 0xff;
	uint8 arg1 = instr >> 16 & 0xff;
	uint8 arg2 = instr >> 24 & 0xff;

Width is:

0	byte
1	2 bytes
2	4 bytes
3	8 bytes
4-7	reserved

The ASCII representation for the most common opcodes, together with the bit
width, happens to be 'A'-'U' when they operate on 4-byte words, and 'a'-'u' when
they operate on 8-byte words.

Opcodes:

	opcode
			index

				representation (1-byte)
					(2-byte)
						(4-byte)
							(8-byte)
				
	halt	0	^@	' '	'@'	'`'		stop execution
	set		1	^A	'!'	'A'	'a'		set target to arg1
	load	2	^B	'"'	'B'	'b'		read target from memory location arg1
	store	3	^C	'#'	'C'	'c'		store arg1 to memory location at target
	push	4	^D	'$'	'D'	'd'		set [--sp] to arg1
	pop		5	^E	'%'	'E'	'e'		set target to [sp++]
	add		6	^F	'&'	'F'	'f'		set target to arg1 + arg2
	sub		7	^G	'''	'G'	'g'		set target to arg1 - arg2
	mul 	8	^H	'('	'H'	'h'		set target to arg1 * arg2
	muls	9	^I	')'	'I'	'i'		set target to arg1 * arg2 (signed)
	div		a	^J	'*'	'J'	'j'		set target to arg1 / arg2
	divs	b	^K	'+'	'K'	'k'		set target to arg1 / arg2 (signed)
	mod		c	^L	','	'L'	'l'		set target to arg1 % arg2
	shr		d	^M	'-'	'M'	'm'		set target to arg1 >> arg2 (logical)
	asr		e	^N	'.'	'N'	'n'		set target to arg1 >> arg2 (arithmetic)
	shl		f	^O	'/'	'O'	'o'		set target to arg1 << arg2
	and		10	^P	'0'	'P'	'p'		set target to arg1 & arg2
	or		12	^Q	'1'	'Q'	'q'		set target to arg1 | arg2
	xor		13	^R	'2'	'R'	'r'		set target to arg1 ^ arg2
	not		14	^S	'3'	'S'	's'		set target to ~arg
	lt		15	^T	'4'	'T'	't'		set target to arg1 < arg2
	gt		16	^U	'5' 'U' 'u'		set target to arg1 > arg2
	le		17	^V	'6' 'V' 'v'		set target to arg1 <= arg2
	ge		18                      set target to arg2 >= arg2
	eq		19                      set target to arg1 == arg2
	neq	                            set target to arg1 != arg2
	if	                            skip next instruction if arg1 == 0

	// call needed?

To perform a nop, use add x, x, 0
To perform a jump, use 

TODO make it so that accessing variables and arguments are done by the same
addressing mode, highest bits == index of var/arg and lowest 3 bits ==
instruction width (000 = 8 bytes)... but then again, this doesn't work. 


Source/target values:

0..31: variables at locations (width * i)
32..63: immediate values (so that value 48, ascii '0', is 0)
64..125: local variables at locations (width * i)
126: sp
127: pc
4-byte immediate: value of next 4 bytes
8-byte immediate: value of next 8 bytes

Maybe we need a frame pointer after all to address variables.

Perhaps make immediates span the values [-16..16] if we can pinch one off
somewhere.

