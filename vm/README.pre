
# VM documentation

## Registers

### Stack pointer `sp`

Stack pointer starts at end of memory and points at the last value
pushed on the stack.

Here's a reference implementation of the stack:

	int64 size = 1024;
	byte mem[size];

	int64* start = (int64*) &mem;
	int64* end = (int64*) (&mem + size);
	int64* sp = end;

Push a value to stack:

	if (sp == start)
		error("stack overflow");
	*--sp = value;

Pop a value from stack:

	if (sp == end)
		error("stack underflow");
	value = *sp++;

### Program counter `pc`

Program counter starts at the start of memory and points at the next
instruction to be executed.  Instructions are 32-bit words.

	int64 size = 1024;
	byte mem[size];

	int32* start = (int32*) &mem;
	int32* end = (int32*) (&mem + size);
	int32* pc = start;

Here's a reference implementation of the instruction decoder:

	while (true) {
		// Decode instruction into [instr, arg1, arg2]

		if (pc < start || pc >= end)
			error("non-existent address");

		int32 instr = *pc++;

		int32 arg1, arg2;

		if (twoword(instr)) {
			if (pc < start || pc >= end)
				error("non-existent address");
			arg1 = *pc++;
		}

		if (threeword(instr)) {
			if (pc < start || pc >= end)
				error("non-existent address");
			arg2 = *pc++;
		}

		// Execute

		switch (instr) {
			// ...
		}
	}

Thus, when an instruction refers to `pc`, it will point to the next instruction
following the instruction itself.  For example,

	add pc, 4	// equivalent go 'goto foo;'
	nop			// will not be executed
foo:
	...

This code is equivalent to the one above:

	set pc, foo
	nop			// will not be executed
foo:
	...

This code results in an infinite loop, since the instruction fits into 32 bits:

	sub pc, 4

## Function call 

Before calling the function, the stack looks like:

	position	contents

				local variable 0
				...
				local variable n (previous sp)
				argument n
				...
				argument 1
				return address
	sp			previous sp

During execution of the function, the stack looks like:

	position	contents


				local variable 0
				...
				local variable n (previous sp)
				argument n
				...
				argument 1
				return address
				previous sp 
				local variable 0
				...
	sp			local variable n

After returning from the function, the stack looks like:

	position	contents

				local variable 0
				...
	sp			local variable n (previous sp)

Assembly sequence for a function call:

	// evaluate local variables arg1, arg2, arg3, and prev_sp = sp
	// a register could be used for prev_sp as well
	push arg3
	push arg2
	push arg1
	push ret
	push prev_sp
	jmp f
ret:
	...

Assembly sequence for f:

f:
	add sp, n	// allocate space for n variables
	... 		// function body

	sub sp, n	// free the allocated space
	ret

The `ret` instruction pops `sp` and `pc` from stack.

Alternatively, f could be implemented as:

f:
	push xx		// push xx
	push yy		// push yy
	push zz		// push zz
	...			// function body
	sub sp, n	// free the allocated space
	ret

The guideline is that the function body should never modify `sp` in the
function body, so that `sp`-relative locations always refer to the same local
variable.

(`ret` could also take an argument that first frees n bytes from the stack.)

## Instructions

In addition, instructions may contain up to two /long arguments/.  They take 32
bits each 

instruction contains a prefix, 

### with 0 arguments

* HALT - stop execution
* NOP  - do nothing

### with 1 argument

* PUSx - push argument denoted by x to stack
* POPx - pop value from stack and place it into `x`

### with 2 arguments

* MVxy
* 

* LOAx, 

32 opcodes should be enough.

Opcode format:

	bits 0..4   (values 0-31)    opcode 
	bits 5..7   (values 0-15)    width
	bits 8..15  (values 0..255)  target (optional)
	bits 16..23 (values 0..255)  argument 1
	bits 24..31 (values 0..255)  argument 2

	uint32 instr = get_instr();
	uint8 int opcode = instr & 0x1f;
	uint8 width = instr >> 5 & 0x07;
	uint8 target = instr >> 8 & 0xff;
	uint8 arg1 = instr >> 16 & 0xff;
	uint8 arg2 = instr >> 24 & 0xff;

Width is:

0	byte
1	2 bytes
2	4 bytes
3	8 bytes
4-7	reserved

The ASCII representation for the most common opcodes, together with the bit
width, happens to be 'A'-'U' when they operate on 4-byte words, and 'a'-'u' when
they operate on 8-byte words.

Opcodes:


	opcode
			index

				representation (1-byte)
					(2-byte)
						(4-byte)
							(8-byte)
				
	hlt		0	^@	' '	'@'	'`'
	set		1	^A	'!'	'A'	'a'
	add		2	^B	'"'	'B'	'b'
	sub		3	^C	'#'	'C'	'c'
	mul 	4	^D	'$'	'D'	'd'
	muls	5	^E	'%'	'E'	'e'
	div		6	^F	'&'	'F'	'f'
	divs	7	^G	'''	'G'	'g'
	shr		8	^H	'('	'H'	'h'
	asr		9	^I	')'	'I'	'i'
	shl		a	^J	'*'	'J'	'j'
	and		b	^K	'+'	'K'	'k'
	or		c	^L	','	'L'	'l'
	xor		d	^M	'-'	'M'	'm'
	not		e	^N	'.'	'N'	'n'
	lt		f	^O	'/'	'O'	'o'
	gt		10	^P	'0'	'P'	'p'
	ge		12	^Q	'1'	'Q'	'q'
	le		13	^R	'2'	'R'	'r'
	eq		14	^S	'3'	'S'	's'
	neq		15	^T	'4'	'T'	't'
	if		16	^U	'5' 'U' 'u'

Source/target values:

0..31: variables at locations (width * i)
32..63: immediate values (so that value 48, ascii '0', is 0)
64..125: local variables at locations (width * i)
126: sp
127: pc

Maybe we need a frame pointer after all to address variables.

Perhaps make immediates span the values [-16..16] if we can pinch one off
somewhere.

